#include "m1.h"
#include "m2.h"
#include "m3.h"
#include "StreetData.h"
#include "draw_feature.h"
#include <cfloat>
#include "LatLon.h"
#include <sstream> 
#include "OSMDatabaseAPI.h"
#include "constants.h"
#include <math.h>
#include <map>
#include <unordered_map>
#include <vector>
#include "easygl/graphics.h"
#include <thread>
#include "OSMDatabaseAPI.h"
#include "tinyfiledialogs/tinyfiledialogs.h"
#include <string>

#define PI 3.14159265
#define DETAIL_LEVEL_1 13
#define DETAIL_LEVEL_2 22
#define DETAIL_LEVEL_3 36
#define DETAIL_LEVEL_4 60
#define LON_TO_DIS 45.015 //longtitude to actual distance factor

using namespace std;
using namespace std::chrono;



std::vector<std::string> street_highway_types; // Able to pass in street segment ID and get a street type
std::unordered_map<unsigned, std::string> building_types;
std::vector<std::string> directions; // Directions that are outputted for a given vector of street segments
std::vector<unsigned> savedPath;


//number of intersections clicked for the path algorithm M3
int twoIntersections = 0; // count the number of intersections clicked on the map
int num_inter = 0;//number of intersections being generated by search path
unsigned pageNumber = 0; //to increment the number of pages used for the direction display
unsigned intersection1; // Intersection id 1 for the path finding
unsigned intersection2; // Intersection id 2 for the path finding

//The two Ids to be used by the algorithm and the path button (intersection clicking on map)
unsigned intersectionIdOne = 0;
unsigned intersectionIdTwo = 0;

//ensure that the user is selecting valid intersections for the algorithm
bool properFirstIntersection = false;
bool properSecondIntersection = false;
bool intersection_one_highlight = false; // true if drawing complete
bool intersection_two_highlight = false; // true if drawing complete
int intersectionresult;//the intersections that match up with the name

bool error_message = false;//check if error message already displayed 
bool intersection = false;//check to see if intersection already exits
bool help_message = false; // if the help message is printed
bool enter_key = false;//check if enter key is pressed
//if direction button was pressed or not
bool condition = false; //if the direction button is pressed the condition is true
bool directionErrorMsg = false; // check if there is a error message displayed if there are no ids given to the direction
bool clickedOnClear; //if the clear button is clicked it equals true and certain map features will not draw


static int highlightedIntersection = -1;
static int highlightedFirstIntersection = -1;
static int highlightedSecondIntersection = -1;
std::vector<unsigned> findResults;
bool street = false;
std::vector<std::vector<unsigned>> layeredFeatures; // Each layer contains an array of featureIDs;
// Use this coordinate system for a conventional 
// graphics coordinate system (ie. with inverted y; origin in top left)
// const t_bound_box initial_coords = t_bound_box(0,1000,1000,0); 
t_bound_box initial_coords;
draw_box search_box;
bool searchbox_mode = false;
bool findClosestIntersectionMode = false;
bool pathGreen = false; // turn the path button green if clicked on
bool drawPath = false; // Whether or not we should draw the path
//check if the search bar is clicked by mouse
bool searchbar_clicked = false;
//input from keyboard
std::string input;





//clears map
void clear_map_data() {
    // Reset saved map data so that new maps can be loaded cleanly
    layeredFeatures.clear();
    findResults.clear();
    highlightedIntersection = -1;
}






void init_features() {
    // This function is used to split up all features (lakes, parks, golf courses, etc.)
    // by layer based on their "layer" OSM tag. OSM Layering goes from -5 to 5 therefore
    // we only need to create a vector of features for 11 layers. (http://wiki.openstreetmap.org/wiki/Key:layer)
    // The purpose of layers is to draw islands on top of lakes correctly and if the features are appropriately tagged
    // they will be layered correctly.
    layeredFeatures.resize(11);
    // layeredFeatures[0] represents layer -5
    // layeredFeatures[1] represents layer -4
    // layeredFeatures[5] represents layer 0
    // layeredFeatures[9] represents layer 4
    // layeredFeatures[10] represents layer 5
    std::map<unsigned long long, unsigned> realWayToWayIndex;
    for (unsigned i = 0; i < getNumberOfWays(); i++) {
        // The OSMDatabase provided in M1 has IDs from 0 to the number of features on that map.
        // The real OSM ID is a 64 bit number that isn't dependent on a city.
        // realWayToWayIndex allows us to convert an OSM ID into a feature ID as used by the functions
        // provided in M1.
        realWayToWayIndex[getWayByIndex(i)->id()] = i;
    }
    for (unsigned i = 0; i < getNumberOfFeatures(); i++) {

        bool found = false;
        unsigned long long featureOSMID = realWayToWayIndex[getFeatureOSMID(i)];

        for (unsigned j = 0; j < getTagCount(getWayByIndex(featureOSMID)); j++) {

            std::string featureTag = getTagPair(getWayByIndex(featureOSMID), j).first;

            if (featureTag == "layer") {
                std::string layerLevel = getTagPair(getWayByIndex(realWayToWayIndex[getFeatureOSMID(i)]), j).second;
                layeredFeatures[std::stoi(layerLevel) + 5].push_back(i); // layeredFeatures goes from indexes 0 to 10 so OSM layer data is off by 5
                found = true;
                break;
            }
        }
        if (!found) { // This means that the feature is on layer 0
            layeredFeatures[5].push_back(i); //  (layer 0 is index 5)
        }
    }
}






void draw_info_highlight() {
    if (highlightedIntersection != -1) {
        draw_info_highlight(highlightedIntersection);
    }
}





//MILESTONE3 FOR THE PATH CLICKING INTERSECTIONS
void draw_intersection_one_highlight() {
    if (highlightedFirstIntersection != -1) {
        draw_intersection_one_highlight(highlightedFirstIntersection);
    }
}





//MILESTONE3 FOR THE PATH CLICKING INTERSECTIONS
void draw_intersection_two_highlight() {
    if (highlightedSecondIntersection != -1) {
        draw_intersection_two_highlight(highlightedSecondIntersection);
    }
}




//draw yellow circle on the intersection where we need info
void draw_info_highlight(unsigned intersectionID) {
    highlightedIntersection = intersectionID; // Save the intersection ID for redrawing later
    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

    LatLon closestIntersectionPos = getIntersectionPosition(intersectionID);
    setcolor(YELLOW);

    fillarc(closestIntersectionPos.lon*scalingFactor, closestIntersectionPos.lat, 0.000013 * StreetData::getObjectPtr()->zoomLevel, 0, 360);
}






//MILESTONE 3 GET FIRST CLICK INTERSECTION
//draws intersection one clicked on screen (yellow circle on the intersection)
void draw_intersection_one_highlight(unsigned intersectionID) {

    highlightedFirstIntersection = intersectionID; // Save the intersection ID for redrawing later
    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

    LatLon closestIntersectionPos = getIntersectionPosition(intersectionID);
    setcolor(YELLOW);

    fillarc(closestIntersectionPos.lon*scalingFactor, closestIntersectionPos.lat, 0.000013 * StreetData::getObjectPtr()->zoomLevel, 0, 360);
}





//MILESTONE 3 GET FIRST CLICK INTERSECTION
//draws intersection two clicked on screen (yellow circle on the intersection)
void draw_intersection_two_highlight(unsigned intersectionID) {

    highlightedSecondIntersection = intersectionID; // Save the intersection ID for redrawing later
    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

    LatLon closestIntersectionPos = getIntersectionPosition(intersectionID);
    setcolor(YELLOW);

    fillarc(closestIntersectionPos.lon*scalingFactor, closestIntersectionPos.lat, 0.000013 * StreetData::getObjectPtr()->zoomLevel, 0, 360);
}





// used to pass the bool into m3 where the direction drawing is handled
bool giveDirectionsButtonPressed() {
    return condition;
}




// used to pass the bool into m3 where the direction no input message drawing is handled
bool giveDirectionsErrorMessage() {
    return directionErrorMsg;
}





void setDirectionsErrorMessage(bool x) {
    directionErrorMsg = x;
}




//helper function to draw the found intersection
void draw_found_intersections() {
    draw_found_intersections(findResults);
}




//function to draw the found intersection
void draw_found_intersections(std::vector<unsigned> findResult) {

    findResults = findResult; // Save the found result for redrawing later.
    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.
    setcolor(YELLOW);

    for (unsigned i = 0; i < findResult.size(); i++) { // Loop through all the found intersections and highlight them
        LatLon findIntersectionPos = getIntersectionPosition(findResult[i]);
        fillarc(findIntersectionPos.lon*scalingFactor, findIntersectionPos.lat, 0.000013 * StreetData::getObjectPtr()->zoomLevel, 0, 360);
        intersectionresult = findResult[i];
    }
}







//draw quit button
void draw_quit() {
    // Draw the exit button in the top right so that the program can exit correctly.
    setcolor(FIREBRICK);
    // Set bounds and draw red square
    double quit_xleft = obtainTranscoord().top_width - 20;
    double quit_xright = obtainTranscoord().top_width;
    double quit_ytop = 0;
    double quit_ybot = 20;

    fillrect(xscrn_to_world(quit_xleft), yscrn_to_world(quit_ytop), xscrn_to_world(quit_xright), yscrn_to_world(quit_ybot));
    setcolor(WHITE);
    // Draw the white X
    quit_xleft += 4;
    quit_xright -= 4;
    quit_ytop += 4;
    quit_ybot -= 4;
    drawline(xscrn_to_world(quit_xleft), yscrn_to_world(quit_ytop), xscrn_to_world(quit_xright), yscrn_to_world(quit_ybot));
    drawline(xscrn_to_world(quit_xright), yscrn_to_world(quit_ytop), xscrn_to_world(quit_xleft), yscrn_to_world(quit_ybot));
}






void find_start_and_end_positions(unsigned streetID, double scalingFactor, LatLon startPos, LatLon endPos, double &startX, double &startY, double &endX, double &endY) {
    startX = startPos.lon*scalingFactor;
    startY = startPos.lat;
    endX = endPos.lon*scalingFactor;
    endY = endPos.lat;
}




//draw all the street names
void draw_street_names() {
    // The function displays the street names of the different types of streets
    // at specific zoom levels.
    // Larger streets are shown at a farther zoom level while minor streets are shown at a higher zoom level
    if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_3) { // If above a certain zoom level don't draw street names.
        return;
    }

    // Set the properties for text.
    setfontsize(10);
    setcolor(0, 176, 255);

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

    for (unsigned i = 0; i < getNumberOfStreets(); i++) {

        std::vector<unsigned> streetSegments = StreetData::getObjectPtr()->streetSegsByStreetID[i]; // Find street segments for a specific street.

        for (unsigned j = 0; j < streetSegments.size(); j++) {

            if (getStreetName(i) != "<unknown>") { // Don't draw a bunch of <unknowns> on the map
                double startX, startY, endX, endY;

                if (getStreetSegmentInfo(streetSegments[j]).curvePointCount == 0) { // Streets segments with no curve points
                    LatLon startPos = getIntersectionPosition(getStreetSegmentInfo(streetSegments[j]).from);
                    LatLon endPos = getIntersectionPosition(getStreetSegmentInfo(streetSegments[j]).to);
                    find_start_and_end_positions(streetSegments[j], scalingFactor, startPos, endPos, startX, startY, endX, endY);
                    draw_slanted_text(getStreetName(i), startX, startY, endX, endY);
                } else { // Street segments with curve points
                    // Draw street name in between "from" and the first curve point
                    LatLon startPos = getIntersectionPosition(getStreetSegmentInfo(streetSegments[j]).from);
                    LatLon endPos = getStreetSegmentCurvePoint(streetSegments[j], 0);
                    find_start_and_end_positions(streetSegments[j], scalingFactor, startPos, endPos, startX, startY, endX, endY);
                    draw_slanted_text(getStreetName(i), startX, startY, endX, endY);

                    // Draw street names between curve points
                    for (unsigned k = 1; k < getStreetSegmentInfo(streetSegments[j]).curvePointCount; k++) {
                        startPos = endPos;
                        endPos = getStreetSegmentCurvePoint(streetSegments[j], k);
                        find_start_and_end_positions(streetSegments[j], scalingFactor, startPos, endPos, startX, startY, endX, endY);
                        draw_slanted_text(getStreetName(i), startX, startY, endX, endY);
                    }

                    // Draw street name in between last curve point and "to"
                    startPos = endPos;
                    endPos = getIntersectionPosition(getStreetSegmentInfo(streetSegments[j]).to);
                    find_start_and_end_positions(streetSegments[j], scalingFactor, startPos, endPos, startX, startY, endX, endY);
                    draw_slanted_text(getStreetName(i), startX, startY, endX, endY);
                }
            }
        }
    }
}







void draw_points_of_interest() {

    settextrotation(0);
    if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_1) { // Don't draw any points of interest if above a define zoom level
        return;
    }

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.


    for (unsigned i = 0; i < getNumberOfPointsOfInterest(); i++) {

        //WANT TO SEE WHAT FOREIGN COUNTRIES HAVE FOR THIS
        //std::cout << getPointOfInterestType(i) << std::endl;

        double longitude = getPointOfInterestPosition(i).lon;
        double latitude = getPointOfInterestPosition(i).lat;
        double scaledLon = longitude*scalingFactor;

        setcolor(FIREBRICK);
        fillrect(scaledLon - 0.00001, latitude - 0.00001, scaledLon + 0.00001, latitude + 0.00001);

        setfontsize(8);
        setlinestyle(SOLID);
        setlinewidth(2);
        setcolor(BLACK);

        // Draws all the points of interests on the map based on what their type is and their zoom level.
        // There are 6 different levels for points of interest and the types that show up on each level were
        // determined by us and hardcoded.
        if (POITYPE[5].find(getPointOfInterestType(i)) != std::string::npos) {
            if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_1 - 11) {
                continue;
            }
            drawtext(scaledLon, latitude + 0.00002, getPointOfInterestName(i), 9999, 9999);
        }


        if (POITYPE[4].find(getPointOfInterestType(i)) != std::string::npos) {
            if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_1 - 7) {
                continue;
            }
            drawtext(scaledLon, latitude + 0.00002, getPointOfInterestName(i), 9999, 9999);
        }


        if (POITYPE[3].find(getPointOfInterestType(i)) != std::string::npos) {

            if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_1 - 11) {
                continue;
            }
            drawtext(scaledLon, latitude + 0.00002, getPointOfInterestName(i), 9999, 9999);
        }


        if (POITYPE[2].find(getPointOfInterestType(i)) != std::string::npos) {

            if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_1 - 7) {
                continue;
            }
            drawtext(scaledLon, latitude + 0.00002, getPointOfInterestName(i), 9999, 9999);
        }


        if (POITYPE[1].find(getPointOfInterestType(i)) != std::string::npos) {

            if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_1 - 9) {
                continue;
            }
            drawtext(scaledLon, latitude + 0.00002, getPointOfInterestName(i), 9999, 9999);
        }


        if (POITYPE[0].find(getPointOfInterestType(i)) != std::string::npos) { // This list o
            if (StreetData::getObjectPtr()->zoomLevel < DETAIL_LEVEL_1 - 12)
                drawtext(scaledLon, latitude + 0.00002, getPointOfInterestName(i), 9999, 9999);
        }

    }
}





// draws the streets on the maps
void draw_streets() {
    setlinestyle(SOLID);
    setlinewidth(2);
    setcolor(BLACK);


    for (unsigned i = 0; i < getNumberOfStreetSegments(); i++) {
        // Determine what type of street segment it is
        std::string roadType = street_highway_types[i];
        if (find(StreetData::getObjectPtr()->highlightedStreetIDs.begin(), StreetData::getObjectPtr()->highlightedStreetIDs.end(), getStreetSegmentInfo(i).streetID) != StreetData::getObjectPtr()->highlightedStreetIDs.end() && street == true) {
            setlinewidth(2);
            setcolor(255, 255, 0);
        } else if (roadType == "motorway" || roadType == "motorway_link" || roadType == "trunk") {
            setlinewidth(2);
            setcolor(255, 143, 0);
        } else if (roadType == "primary") {
            setlinewidth(2);
            setcolor(70, 70, 70);
        } else if (roadType == "secondary") {
            setlinewidth(2);
            setcolor(125, 125, 125);
        } else if (street_highway_types[i] == "tertiary") {
            setlinewidth(2);
            setcolor(180, 180, 180);
        } else if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_4) {
            continue;
        } else if (street_highway_types[i] == "unclassified" || street_highway_types[i] == "road" || street_highway_types[i] == "service" || street_highway_types[i] == "residential" ||
                street_highway_types[i] == "primary_link" || street_highway_types[i] == "secondary_link" || street_highway_types[i] == "tertiary_link" || street_highway_types[i] == "pedestrian" || street_highway_types[i] == "track") {
            setlinewidth(1);
            setcolor(180, 180, 180);
        } else {
            setcolor(RED);
        }


        draw_street_segment(i);
    }
}






void draw_street_segment(unsigned streetID) { // Draw an individual street segment
    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.
    if (getStreetSegmentInfo(streetID).curvePointCount == 0) { // Handle street segments with no curve points

        double beginX = getIntersectionPosition(getStreetSegmentInfo(streetID).from).lon*scalingFactor;
        double beginY = getIntersectionPosition(getStreetSegmentInfo(streetID).from).lat;
        double endX = getIntersectionPosition(getStreetSegmentInfo(streetID).to).lon*scalingFactor;
        double endY = getIntersectionPosition(getStreetSegmentInfo(streetID).to).lat;

        drawline(beginX, beginY, endX, endY);

        if (getStreetSegmentInfo(streetID).oneWay) {
            double angle = atan2(endY - beginY, endX - beginX);
            t_point points[3];

            points[0].x = endX;
            points[0].y = endY;
            points[1].x = endX + 0.00003 * cos(angle + PI * 7 / 8);
            points[1].y = endY + 0.00003 * sin(angle + PI * 7 / 8);
            points[2].x = endX + 0.00003 * cos(angle + PI * 9 / 8);
            points[2].y = endY + 0.00003 * sin(angle + PI * 9 / 8);

            fillpoly(points, 3);
        }


    } else { // Handle street segments with curve points
        // Draw from beginning of street segment to first curve point
        double beginX = getIntersectionPosition(getStreetSegmentInfo(streetID).from).lon*scalingFactor;
        double beginY = getIntersectionPosition(getStreetSegmentInfo(streetID).from).lat;
        double endX = getStreetSegmentCurvePoint(streetID, 0).lon*scalingFactor;
        double endY = getStreetSegmentCurvePoint(streetID, 0).lat;

        drawline(beginX, beginY, endX, endY);


        for (unsigned j = 1; j < getStreetSegmentInfo(streetID).curvePointCount; j++) { // Draw in between curve points

            beginX = getStreetSegmentCurvePoint(streetID, j - 1).lon*scalingFactor;
            beginY = getStreetSegmentCurvePoint(streetID, j - 1).lat;
            endX = getStreetSegmentCurvePoint(streetID, j).lon*scalingFactor;
            endY = getStreetSegmentCurvePoint(streetID, j).lat;

            drawline(beginX, beginY, endX, endY);
        }

        // Draw from last curve point to end of street segment
        endX = getIntersectionPosition(getStreetSegmentInfo(streetID).to).lon*scalingFactor;
        endY = getIntersectionPosition(getStreetSegmentInfo(streetID).to).lat;
        beginX = getStreetSegmentCurvePoint(streetID, getStreetSegmentInfo(streetID).curvePointCount - 1).lon*scalingFactor;
        beginY = getStreetSegmentCurvePoint(streetID, getStreetSegmentInfo(streetID).curvePointCount - 1).lat;

        drawline(beginX, beginY, endX, endY);


        if (getStreetSegmentInfo(streetID).oneWay) {
            // Draw the one way arrow if the street is one way
            double angle = atan2(endY - beginY, endX - beginX);
            t_point points[3];

            points[0].x = endX;
            points[0].y = endY;
            points[1].x = endX + 0.00003 * cos(angle + PI * 7 / 8);
            points[1].y = endY + 0.00003 * sin(angle + PI * 7 / 8);
            points[2].x = endX + 0.00003 * cos(angle + PI * 9 / 8);
            points[2].y = endY + 0.00003 * sin(angle + PI * 9 / 8);

            fillpoly(points, 3);
        }
    }
}






void initialize_building_types() {
    // This function is used to determine building types and store them into a "building_types" vector
    // Each building is a feature that is a closed set of points stored as a "way" in the OSM database.
    // getWayByIndex() returns an ID that is used by the functions provided in M1 but is not useful for
    // obtaining the tags from the way.
    std::map<unsigned long long, unsigned> realWayToWayIndex;

    for (unsigned i = 0; i < getNumberOfWays(); i++) {
        realWayToWayIndex[getWayByIndex(i)->id()] = i;
    }

    for (unsigned i = 0; i < getNumberOfFeatures(); i++) {

        for (unsigned j = 0; j < getTagCount(getWayByIndex(realWayToWayIndex[getFeatureOSMID(i)])); j++) {

            unsigned long long featureOSMID = realWayToWayIndex[getFeatureOSMID(i)];
            if (getTagPair(getWayByIndex(featureOSMID), j).first == "building") {
                building_types[i] = getTagPair(getWayByIndex(featureOSMID), j).second;
            }
        }
    }

}






void initialize_street__highway_types() {
    // Same thing as initialize_building_types
    street_highway_types.resize(getNumberOfStreetSegments());
    std::map<unsigned long long, unsigned> realWayToWayIndex;

    for (unsigned i = 0; i < getNumberOfWays(); i++) {
        realWayToWayIndex[getWayByIndex(i)->id()] = i;
    }
    for (unsigned i = 0; i < getNumberOfStreetSegments(); i++) {

        for (unsigned j = 0; j < getTagCount(getWayByIndex(realWayToWayIndex[getStreetSegmentInfo(i).wayOSMID])); j++) {

            if (getTagPair(getWayByIndex(realWayToWayIndex[getStreetSegmentInfo(i).wayOSMID]), j).first == "highway") {
                street_highway_types[i] = getTagPair(getWayByIndex(realWayToWayIndex[getStreetSegmentInfo(i).wayOSMID]), j).second;
                break;
            }
        }
    }
}





//draw the different types of land and water bodies
void draw_features() {

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

    for (unsigned i = 0; i < layeredFeatures.size(); i++) { // Draw the features according to their appropriate OSM layer first

        for (unsigned j = 0; j < layeredFeatures[i].size(); j++) { // Draw these features first within that OSM layer
            switch (getFeatureType(layeredFeatures[i][j])) {
                case Lake:
                    draw_lake(layeredFeatures[i][j], scalingFactor);
                    break;
                case Island:
                    draw_island(layeredFeatures[i][j], scalingFactor);
                    break;
                case Park:
                    draw_park(layeredFeatures[i][j], scalingFactor);
                    break;
                case Greenspace:
                    draw_greenspace(layeredFeatures[i][j], scalingFactor);
                    break;
                default:
                    break;
            }
        }

        for (unsigned j = 0; j < layeredFeatures[i].size(); j++) { // Draw these features second within that OSM layer
            switch (getFeatureType(layeredFeatures[i][j])) {
                case Stream:
                    if (StreetData::getObjectPtr()->zoomLevel < DETAIL_LEVEL_4) {
                        draw_stream(layeredFeatures[i][j], scalingFactor);
                    }
                    break;
                case River:
                    draw_river(layeredFeatures[i][j], scalingFactor);
                    break;
                case Golfcourse:
                    draw_golfcourse(layeredFeatures[i][j], scalingFactor);
                    break;
                case Building:
                    if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_3) {
                        break;
                    }
                    if (StreetData::getObjectPtr()->zoomLevel > DETAIL_LEVEL_2 && (building_types[layeredFeatures[i][j]] == "house" || building_types[layeredFeatures[i][j]] == "apartments" || building_types[layeredFeatures[i][j]] == "residential" || building_types[layeredFeatures[i][j]] == "detached" || building_types[layeredFeatures[i][j]] == "bungalow" || building_types[layeredFeatures[i][j]] == "yes")) {
                        break;
                    }
                    draw_building(layeredFeatures[i][j], scalingFactor);
                    break;
                case Beach:
                    draw_beach(layeredFeatures[i][j], scalingFactor);
                    break;
                case Shoreline:
                    draw_shoreline(layeredFeatures[i][j], scalingFactor);
                    break;
                default:
                    break;
            }
        }
    }
}





//draw scale line - changes depending on zoom level
void draw_scale() {

    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(3);
    setcolor(BLACK);

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.

    int x_coord = obtainTranscoord().top_width - 120;
    int text_x_coord = obtainTranscoord().top_width - 100;
    int text_y_coord = obtainTranscoord().top_height - 75;

    //coordinates of where the scaling line is located

    LatLon point1(obtainTranscoord().top_height - 90, xscrn_to_world(1120) / cos(lat_avg));
    LatLon point2(obtainTranscoord().top_height - 90, xscrn_to_world(1180) / cos(lat_avg));
    double distance = find_distance_between_two_points(point1, point2);

    //scale length 3000m
    if (distance >= 2000) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "3km", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 3000), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 3000), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 3000), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }        //scale length 1000m
    else if (distance >= 990) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "1km", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 1000), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 1000), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 1000), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }        //scale length 500m
    else if (distance >= 340) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "500m", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 500), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 500), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 500), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }        //scale length 100m
    else if (distance >= 70) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "100m", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 100), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 100), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 100), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }        //scale length 50m
    else if (distance >= 24) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "50m", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 50), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 50), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 50), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }        //scale length 10m
    else if (distance >= 9) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "10m", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 10), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 10), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 10), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }        //scale length 5m
    else if (distance >= 5) {
        drawtext(xscrn_to_world(text_x_coord), yscrn_to_world(text_y_coord), "5m", 150, FLT_MAX);
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 5), yscrn_to_world(obtainTranscoord().top_height - 90));
        drawline(xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90), xscrn_to_world(x_coord), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
        drawline(xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 5), yscrn_to_world(obtainTranscoord().top_height - 90 + 1), xscrn_to_world(x_coord + (x_coord - (obtainTranscoord().top_width - 160)) / distance * 5), yscrn_to_world(obtainTranscoord().top_height - 90 - 7));
    }
}





//the general function that draws the basic buttons on the custom interface (milestone 2)
void draw_buttons() {
    settextrotation(0);
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(3);

    //zoom in button coordinates
    double zoom_in_xleft = obtainTranscoord().top_width - 120;
    double zoom_in_xright = obtainTranscoord().top_width - 80;
    double zoom_in_ytop = obtainTranscoord().top_height - 150;
    double zoom_in_ybot = obtainTranscoord().top_height - 120;

    //zoom out button coordinates
    double zoom_out_xleft = obtainTranscoord().top_width - 65;
    double zoom_out_xright = obtainTranscoord().top_width - 25;
    double zoom_out_ytop = obtainTranscoord().top_height - 150;
    double zoom_out_ybot = obtainTranscoord().top_height - 120;

    //zoom in button
    setcolor(WHITE);
    fillrect(xscrn_to_world(zoom_in_xleft), yscrn_to_world(zoom_in_ytop), xscrn_to_world(zoom_in_xright), yscrn_to_world(zoom_in_ybot));

    //zoom in icon
    setcolor(BLACK);
    drawline(xscrn_to_world(zoom_in_xleft + 10), yscrn_to_world((zoom_in_ytop + zoom_in_ybot) / 2), xscrn_to_world(zoom_in_xright - 10), yscrn_to_world((zoom_in_ytop + zoom_in_ybot) / 2));
    drawline(xscrn_to_world((zoom_in_xleft + zoom_in_xright) / 2), yscrn_to_world(zoom_in_ytop + 5), xscrn_to_world((zoom_in_xleft + zoom_in_xright) / 2), yscrn_to_world(zoom_in_ybot - 5));

    //zoom out button
    setcolor(WHITE);
    fillrect(xscrn_to_world(zoom_out_xleft), yscrn_to_world(zoom_out_ytop), xscrn_to_world(zoom_out_xright), yscrn_to_world(zoom_out_ybot));


    //zoom out icon
    setcolor(BLACK);
    drawline(xscrn_to_world(zoom_out_xleft + 10), yscrn_to_world((zoom_out_ytop + zoom_out_ybot) / 2), xscrn_to_world(zoom_out_xright - 10), yscrn_to_world((zoom_out_ytop + zoom_out_ybot) / 2));

    // Load button
    double load_xleft = obtainTranscoord().top_width - 92.5;
    double load_xright = obtainTranscoord().top_width - 52.5;
    double load_ytop = obtainTranscoord().top_height - 165;
    double load_ybot = obtainTranscoord().top_height - 195;

    //load button
    setcolor(WHITE);
    fillrect(xscrn_to_world(load_xleft), yscrn_to_world(load_ytop), xscrn_to_world(load_xright), yscrn_to_world(load_ybot));
    //load text
    setcolor(BLACK);
    drawtext(xscrn_to_world(load_xleft + 20), yscrn_to_world(load_ytop - 15), "Load", 150, 100);


    double find_xleft = obtainTranscoord().top_width - 92.5;
    double find_xright = obtainTranscoord().top_width - 52.5;
    double find_ytop = obtainTranscoord().top_height - 255;
    double find_ybot = obtainTranscoord().top_height - 285;

    // Find button
    setcolor(WHITE);
    fillrect(xscrn_to_world(find_xleft), yscrn_to_world(find_ytop), xscrn_to_world(find_xright), yscrn_to_world(find_ybot));
    setcolor(BLACK);
    drawtext(xscrn_to_world(find_xleft + 20), yscrn_to_world(find_ytop - 15), "Find", 150, FLT_MAX);

}






//the search bar at the top of the screen is drawn - used for intersection and street inputs
void draw_searchbox(bool searchbox_mode) {
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(3);

    //coordinates of the search box
    double box_xleft = obtainTranscoord().top_width / 2 - 170;
    double box_xright = obtainTranscoord().top_width / 2 + 170;
    double box_ytop = obtainTranscoord().top_height / 10 - 20;
    double box_ybot = obtainTranscoord().top_height / 10 + 20;
    //draw search box
    setcolor(WHITE);
    fillrect(xscrn_to_world(box_xleft), yscrn_to_world(box_ytop), xscrn_to_world(box_xright), yscrn_to_world(box_ybot));

    //draw small box
    fillrect(xscrn_to_world(box_xright - 35), yscrn_to_world(box_ytop), xscrn_to_world(box_xright), yscrn_to_world(box_ybot));
    //draw arrow
    setcolor(BLACK);
    setlinewidth(2);
    drawline(xscrn_to_world(box_xright - 15), yscrn_to_world(box_ytop + 10), xscrn_to_world(box_xright - 15), yscrn_to_world(box_ytop + 25));
    drawline(xscrn_to_world(box_xright - 32), yscrn_to_world(box_ytop + 25), xscrn_to_world(box_xright - 14), yscrn_to_world(box_ytop + 25));
    drawline(xscrn_to_world(box_xright - 32), yscrn_to_world(box_ytop + 25), xscrn_to_world(box_xright - 20), yscrn_to_world(box_ytop + 20));
    drawline(xscrn_to_world(box_xright - 32), yscrn_to_world(box_ytop + 25), xscrn_to_world(box_xright - 20), yscrn_to_world(box_ytop + 30));
    //draw text
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(1);
    if (StreetData::clear == true)
        return;
    else if (draw_box::getinput().size() <= 31 && StreetData::clear == false)
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(obtainTranscoord().top_height / 10), draw_box::getinput(), 1, 1);
    else if (StreetData::clear == false)
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(obtainTranscoord().top_height / 10), draw_box::getinput().substr(draw_box::getinput().size() - 30, 30), 1, 1);

}







void draw_info_button(bool findClosestIntersectionMode) {
    settextrotation(0);
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(3);

    if (findClosestIntersectionMode) {
        setcolor(GREEN);
    } else {
        setcolor(WHITE);
    }

    // Info button
    double info_xleft = obtainTranscoord().top_width - 92.5;
    double info_xright = obtainTranscoord().top_width - 52.5;
    double info_ytop = obtainTranscoord().top_height - 210;
    double info_ybot = obtainTranscoord().top_height - 240;

    fillrect(xscrn_to_world(info_xleft), yscrn_to_world(info_ytop), xscrn_to_world(info_xright), yscrn_to_world(info_ybot));
    setcolor(BLACK);
    drawtext(xscrn_to_world(info_xleft + 20), yscrn_to_world(info_ytop - 15), "Info", 1, 1);

}







void draw_map() {
    // Initialization
    initialize_street__highway_types();
    initialize_building_types();
    init_features();
    init_graphics("Mapping", t_color(225, 225, 225));

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2;
    double scalingFactor = cos(lat_avg * DEG_TO_RAD);

    // Set the initial coordinates for the map
    initial_coords = t_bound_box(StreetData::getObjectPtr()->lonIntersectionMin*scalingFactor,
            StreetData::getObjectPtr()->latIntersectionMin,
            StreetData::getObjectPtr()->lonIntersectionMax*scalingFactor,
            StreetData::getObjectPtr()->latIntersectionMax);
    set_visible_world(initial_coords);
    // Event loop which handles the mouse and keyboard events
    event_loop(act_on_mousebutton, NULL, act_on_keypress, drawscreen);
    // Clean up
    clear_map_data();
    close_graphics();
}






//MILESTONE 3
//If in the search bar unknown strings are entered, let the user know
void draw_error_message(std::string error_message_input) {
    settextrotation(0);
    setfontsize(14);
    setlinestyle(SOLID);
    setlinewidth(3);
    setcolor(WHITE);

    //location of suggestion info area
    double sinfo_xleft = obtainTranscoord().top_width / 2 - 170;
    double sinfo_ytop = obtainTranscoord().top_height / 10 + 25;
    double sinfo_xright = obtainTranscoord().top_width / 2 + 170;
    double sinfo_ybot = obtainTranscoord().top_height / 10 + 70;
    fillrect(xscrn_to_world(sinfo_xleft), yscrn_to_world(sinfo_ytop), xscrn_to_world(sinfo_xright), yscrn_to_world(sinfo_ybot));
    setcolor(BLACK);
    if (error_message_input == "intersection")
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(sinfo_ytop + 25), "Sorry, no such intersection is found", 1, 1);
    else if (error_message_input == "street")
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(sinfo_ytop + 25), "Sorry, no such street is found", 1, 1);

}






//auto completes the words
//assumes the beginning of the input is valid
std::string partialStreetComplete(std::string filterString) {
    // The compare operator which is used for the sorting algorithm
    struct StreetCompareOperator {

        bool operator()(const std::string &lhs, const std::string &rhs) {
            unsigned streetSegCount1 = 0;
            for (unsigned j = 0; j < StreetData::getObjectPtr()->streetIDsByName[lhs].size(); j++) {
                streetSegCount1 += StreetData::getObjectPtr()->streetSegsByStreetID[StreetData::getObjectPtr()->streetIDsByName[lhs][j]].size();
            }
            unsigned streetSegCount2 = 0;
            for (unsigned j = 0; j < StreetData::getObjectPtr()->streetIDsByName[rhs].size(); j++) {
                streetSegCount2 += StreetData::getObjectPtr()->streetSegsByStreetID[StreetData::getObjectPtr()->streetIDsByName[rhs][j]].size();
            }
            if (streetSegCount1 > streetSegCount2) {
                return true;
            } else {
                return false;
            }
        }
    };
    std::vector<std::string> possibleMatches; // All the possible matches for the partial POI name
    for (unsigned i = 0; i < getNumberOfStreets(); i++) {
        std::string currentStreetName = getStreetName(i);
        if (currentStreetName.size() >= filterString.size() && currentStreetName.substr(0,filterString.size()) == filterString) {// Make sure the filterString isn't long than the currentPOIName before we check to see if the filter string is the beginning of the currentPOIName
            if (filterString == currentStreetName) {// A special case for if the name is EXACTLY the filterName
                possibleMatches.clear();
                possibleMatches.push_back(currentStreetName);
                break;
            } else {
                if (std::find(possibleMatches.begin(), possibleMatches.end(), currentStreetName) == possibleMatches.end()) {
                    possibleMatches.push_back(currentStreetName);
                }
            }
        }
    }
    std::sort(possibleMatches.begin(), possibleMatches.end(), StreetCompareOperator());
    if (possibleMatches.size() >= 1) {
        return possibleMatches[0]; // Return the POI name with the most POIS
    } else {
        return "ERROR"; // If no POI was found return error
    }
}






//auto completes the point of interest names
//assumes the beginning of the input is valid
std::string partialPOIComplete(std::string filterString) {
    // The compare operator which is used for the sorting algorithm
    struct POICompareOperator {

        bool operator()(const std::string &lhs, const std::string &rhs) {
            if (StreetData::getObjectPtr()->POIByName[lhs].size() > StreetData::getObjectPtr()->POIByName[rhs].size()) {
                return true;
            } else {
                return false;
            }
        }
    };
    std::vector<std::string> possibleMatches; // All the possible matches for the partial POI name
    for (unsigned i = 0; i < getNumberOfPointsOfInterest(); i++) {
        std::string currentPOIName = getPointOfInterestName(i);
        if (currentPOIName.size() >= filterString.size() && currentPOIName.substr(0,filterString.size()) == filterString) { // Make sure the filterString isn't long than the currentPOIName before we check to see if the filter string is the beginning of the currentPOIName
            if (filterString == currentPOIName) { // A special case for if the name is EXACTLY the filterName
                possibleMatches.clear();
                possibleMatches.push_back(currentPOIName);
                break;
            } else {
                if (std::find(possibleMatches.begin(), possibleMatches.end(), currentPOIName) == possibleMatches.end()) {
                    possibleMatches.push_back(currentPOIName);
                }
            }
        }
    }
    std::sort(possibleMatches.begin(),possibleMatches.end(),POICompareOperator()); // This sorts the vector so that the POI name with more POIs is at the top
    if (possibleMatches.size() >= 1) {
        return possibleMatches[0]; // Return the POI name with the most POIS
    } else {
        return "ERROR"; // If no POI was found return error
    }
}






//depending on the coordinates pressed - it will call certain functions
//the function makes the areas where buttons are drawn sensitive to clicking
void act_on_keypress(char c, int keysym) {
    std::cout << "time it takes is 341810 ms" << std::endl;
    StreetData::clear = false;
    if (enter_key == true) {
        input.clear();
        enter_key = false;
    }
    //check if any intersections already drawn
    if (intersection == true) {
        drawscreen();
        intersection = false;
    }
    //check if error message is already cleared
    if (error_message == true) {
        clearscreen();
        drawscreen();
        error_message = false;
    }



    //if search bar is clicked
    if (searchbar_clicked == true) {
        //input can be accepted by enter key
        // Two intersection input
        if ((keysym == 65293 && input.size()!=0 && input.find("&") != std::string::npos && pathGreen == true)) {
            std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
            StreetData::clear = false;
            StreetData::zoom_fitt = false;
            enter_key = true;

            //parameter for draw_error message function
            std::string error_message_input = "intersection";
            //would get rid of the street highlighted earlier
            std::string string;
            StreetData::getObjectPtr()->highlightedStreetIDs = StreetData::getObjectPtr()->streetIDsByName[string];
            //find feature
            std::size_t found = input.find("&");
            std::string street1, street2;
            street1 = input.substr(0, found);

            //check if the last character is whitespace
            char lastchar;
            lastchar = street1[street1.length() - 1];
            if (lastchar == ' ')
                street1.erase(street1.end() - 1, street1.end());
            std::cout << street1 << std::endl;
            street2 = input.substr(found + 1, input.size());

            //check if the first character is whitespace
            if (street2[0] == ' ')
                street2.erase(0, 1);
            std::cout << street2 << std::endl;
            std::string correctStreet1 = partialStreetComplete(street1);
            std::string correctStreet2 = partialStreetComplete(street2);
            std::vector<unsigned> backup;
            std::vector<unsigned> result = find_intersection_ids_from_street_names(correctStreet1, correctStreet2);
            std::cout << "Intersection IDs: ";

            //backup vector so that the second time when the line is drawn the intersection won't
            backup = result;
            clearscreen();
            if (num_inter == 0)
                draw_found_intersections(result);
            if (num_inter == 1) {
                result.clear();
                draw_found_intersections(result);

            }
            result = backup;
            
            if (num_inter == 0) {
                if (result.size() > 0) {
                    intersection1 = result[0];
                }
            }
            //draw path when there are 2 intersections are inserted
            if (num_inter == 1 && !result.empty()) {
                if (result.size() > 0) {
                    intersection2 = result[0];
                }
                drawPath = true;
                condition = true;
                pageNumber = 0;
                savedPath = find_path_between_intersections(intersection1,intersection2);
                directions = get_directions(savedPath);
                twoIntersections = 2;
                num_inter = 0;
            }

            //count the number of intersections
            if (num_inter < 2) {
                num_inter++;
            }

            //would zoom in to that specific intersection
            if (StreetData::zoom_fitt == false) {
                double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
                double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.
                //std::cout << getIntersectionPosition(intersectionresult).lon*scalingFactor << "!" << std::endl;
                //std::cout << getIntersectionPosition(intersectionresult).lat << "!" << std::endl;

                zoom_fit(drawscreen, getIntersectionPosition(intersectionresult).lon*scalingFactor, getIntersectionPosition(intersectionresult).lat, StreetData::zoom_fitt);
            }

            //stop increment and function when number of intersections reaches 2
            if (num_inter == 2)
                pathGreen = false;
            intersection = true;
            drawscreen();
            
            //calculating function duration
                std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<microseconds>( t2 - t1 ).count();
                std::cout << "time it takes is " << duration << " ms" << std::endl;
            //if can't find any suggested streets, print error message
            if (correctStreet1 == "ERROR" || correctStreet2 == "ERROR") {
                draw_error_message(error_message_input);
                error_message = true;
            }
            
        }
        
        //one intersection input
        else if ((keysym == 65293 && input.size()!=0 && input.find("&") != std::string::npos && pathGreen == false)) {
            std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
            StreetData::clear = false;
            StreetData::zoom_fitt = false;
            enter_key = true;

            //parameter for draw_error message function
            std::string error_message_input = "intersection";
            //would get rid of the street highlighted earlier
            std::string string;
            StreetData::getObjectPtr()->highlightedStreetIDs = StreetData::getObjectPtr()->streetIDsByName[string];
            //find feature
            std::size_t found = input.find("&");
            std::string street1, street2;
            street1 = input.substr(0, found);

            //check if the last character is whitespace
            char lastchar;
            lastchar = street1[street1.length() - 1];
            if (lastchar == ' ')
                street1.erase(street1.end() - 1, street1.end());
            //std::cout << street1 << std::endl;
            street2 = input.substr(found + 1, input.size());

            //check if the first character is whitespace
            if (street2[0] == ' ')
                street2.erase(0, 1);
            //std::cout << street2 << std::endl;
            std::string correctStreet1 = partialStreetComplete(street1);
            std::string correctStreet2 = partialStreetComplete(street2);
            std::vector<unsigned> result = find_intersection_ids_from_street_names(correctStreet1, correctStreet2);
            //std::cout << "Intersection IDs: ";


            clearscreen();
            draw_found_intersections(result);

            //would zoom in to that specific intersection
            if (StreetData::zoom_fitt == false) {
                double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
                double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.
                //std::cout << getIntersectionPosition(intersectionresult).lon * scalingFactor << "!" << std::endl;
                //std::cout << getIntersectionPosition(intersectionresult).lat << "!" << std::endl;
                zoom_fit(drawscreen, getIntersectionPosition(intersectionresult).lon*scalingFactor, getIntersectionPosition(intersectionresult).lat, StreetData::zoom_fitt);
                
                //calculating function duration
                std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<microseconds>( t2 - t1 ).count();
                std::cout << "time it takes is " << duration << " ms" << std::endl;
            }
            
            
            intersection = true;
            drawscreen();
            //if can't find any suggested streets, print error message
            if (correctStreet1 == "ERROR" || correctStreet2 == "ERROR") {
                draw_error_message(error_message_input);
                error_message = true;
            }
        }            //Point of Interest
        else if (keysym == 65293 && input.size() != 0 && pathGreen == true) {
            StreetData::zoom_fitt = false;
            StreetData::clear = false;
            enter_key = true;
            if (street == true) {
                drawscreen();
                street = false;
            }
            //parameter for draw_error message function
            std::string error_message_input = "street";
            //check if the name input is correct
            std::string correct_name = partialPOIComplete(input);


            if (correct_name != "ERROR") {
                drawPath = true;
                condition = true;
                savedPath = find_path_to_point_of_interest(intersection1, correct_name);
                directions = get_directions(savedPath);
                twoIntersections = 2;
                num_inter = 0;
                clearscreen();
                //would zoom in to that specific street
                if (StreetData::zoom_fitt == false) {
                    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
                    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

                    unsigned lastStreetSegment = savedPath[savedPath.size() - 1];
                    LatLon poiPOS = getIntersectionPosition(getStreetSegmentInfo(lastStreetSegment).to);
                    double beginY = poiPOS.lat;
                    double beginX = poiPOS.lon * scalingFactor;
                    zoom_fit(drawscreen, beginX, beginY, StreetData::zoom_fitt);

                }
                drawscreen();
            } else {
                draw_error_message(error_message_input);
                error_message = true;
            }


        }
        //single street name
        else if (keysym == 65293 && input.size() != 0 && pathGreen == false) {
            //calculating function duration
            //std::cout<< "i am here"<< std::endl;
            std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
            StreetData::zoom_fitt = false;
            StreetData::clear = false;
            enter_key = true;
            if (street == true) {
                drawscreen();
                street = false;
            }
            //parameter for draw_error message function
            std::string error_message_input = "street";

            std::string correct_name = partialStreetComplete(input);

            if (StreetData::getObjectPtr()->streetIDsByName.find(correct_name) != StreetData::getObjectPtr()->streetIDsByName.end() && correct_name != "ERROR") {
                clearscreen();
                StreetData::getObjectPtr()->highlightedStreetIDs = StreetData::getObjectPtr()->streetIDsByName[correct_name];
                //would zoom in to that specific street
                if (StreetData::zoom_fitt == false) {

                    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2; // Get the average latitude.
                    double scalingFactor = cos(lat_avg * DEG_TO_RAD); // Find the scaling factor.

                    std::vector<unsigned> streetIDs = StreetData::getObjectPtr()->streetIDsByName[correct_name];
                    std::vector<unsigned> streetSegs = StreetData::getObjectPtr()->streetSegsByStreetID[streetIDs[0]];
                    unsigned i = streetSegs.size() / 2;
                    double beginX = getIntersectionPosition(getStreetSegmentInfo(streetSegs[i]).from).lon*scalingFactor;
                    double beginY = getIntersectionPosition(getStreetSegmentInfo(streetSegs[i]).from).lat;
                    zoom_fit(drawscreen, beginX, beginY, StreetData::zoom_fitt);

                    //calculating function duration
                std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<microseconds>( t2 - t1 ).count();
                std::cout << "time it takes is " << duration << " ms" << std::endl;
                }
                street = true;
                drawscreen();
                
                
            }
            if (correct_name == "ERROR") {
                    draw_error_message(error_message_input);
                    error_message = true;
            }
            
        }
        //backspace function
        if (keysym == 65288 && input.size() != 0)
            input.pop_back();

        else if (keysym < 256)
            input += c;

        setfontsize(10);
        setlinestyle(SOLID);
        setlinewidth(3);
        search_box.updateinput(input);
        search_box.draw(searchbar_clicked);
    }
}






void draw_path(std::vector<unsigned> path) {
    // Really straightforward function, given a saved path we draw each street segment for that saved path
    setlinewidth(4);
    setcolor(RED);
    for (unsigned i = 0; i < path.size(); i++) {
        draw_street_segment(path[i]);
    }
}






void act_on_mousebutton(float x, float y, t_event_buttonPressed button_info) {
    
    StreetData::zoom_fitt = true;
    
    //detect if error message should be cleared  
    if (error_message == true) {
        clearscreen();
        drawscreen();
        error_message = false;
    }


    //detect if mouse clicked on left search area of search box
    double box_xleft = obtainTranscoord().top_width / 2 - 170;
    double box_xright = obtainTranscoord().top_width / 2 + 170;
    double box_ytop = obtainTranscoord().top_height / 10 - 20;
    double box_ybot = obtainTranscoord().top_height / 10 + 20;

    if (xworld_to_scrn(x) >= box_xleft && xworld_to_scrn(x) <= box_xright && yworld_to_scrn(y) >= box_ytop && yworld_to_scrn(y) <= box_ybot) {
        searchbar_clicked = true;
        search_box.draw(searchbar_clicked);
    } else {
        searchbar_clicked = false;
        search_box.draw(searchbar_clicked);
    }


    //detect if mouse clicked on arrow of search box
    if (xworld_to_scrn(x)>=box_xright - 35 && xworld_to_scrn(x) <= box_xright && yworld_to_scrn(y)<=box_ybot && yworld_to_scrn(y)>=box_ytop && input.find("&") != std::string::npos){
        std::size_t found = input.find("&");
        std::string street1, street2;
        street1 = input.substr(0, found);
        std::cout << street1 << std::endl;
        street2 = input.substr(found + 1, input.size());
        std::cout << street2 << std::endl;
        std::vector<unsigned> result = find_intersection_ids_from_street_names(street1, street2);
        std::cout << "Intersection IDs: ";

        for (unsigned i = 0; i < result.size(); i++) {
            std::cout << result[i];
            if (i != result.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << std::endl;
        draw_found_intersections(result);
        input.clear();
    }

    if (findClosestIntersectionMode) {
        intersection_highlight(x, y);
        findClosestIntersectionMode = false;
        draw_info_button(findClosestIntersectionMode);
    }




    //MILESTONE3 HIGHLIGHT CLICKED INTERSECTION
    if (pathGreen && button_info.ctrl_pressed) {

        //highlight intersection only if there are less than 2 interactions (tracked by global counter)
        if (twoIntersections < 2)
            click_two_intersections(x, y);
        twoIntersections = twoIntersections + 1;

        //max 2 clicks has occurred - path button back to white
        if (twoIntersections > 1) {
            pathGreen = false;
            draw_path_button(pathGreen);

            //Now that the user has clicked on two spots the button resets itself to white and is ready to be pressed again for two more inputs
            //just needed to reset the global counter
            twoIntersections = 0;
        }
    }




    //zoom in button coordinates
    double zoom_in_xleft = obtainTranscoord().top_width - 120;
    double zoom_in_xright = obtainTranscoord().top_width - 80;
    double zoom_in_ytop = obtainTranscoord().top_height - 150;
    double zoom_in_ybot = obtainTranscoord().top_height - 120;
    
    

    //zoom out button coordinates
    double zoom_out_xleft = obtainTranscoord().top_width - 65;
    double zoom_out_xright = obtainTranscoord().top_width - 25;
    double zoom_out_ytop = obtainTranscoord().top_height - 150;
    double zoom_out_ybot = obtainTranscoord().top_height - 120;
    

    //detect if mouse clicked inside the square, zoom in if it is
    if (xworld_to_scrn(x) >= zoom_in_xleft && xworld_to_scrn(x) <= zoom_in_xright && yworld_to_scrn(y) >= zoom_in_ytop && yworld_to_scrn(y) <= zoom_in_ybot) {
        zoom_in(drawscreen);
    }

    //detect if mouse clicked inside the square, zoom out if it is
    if (xworld_to_scrn(x) >= zoom_out_xleft && xworld_to_scrn(x) <= zoom_out_xright && yworld_to_scrn(y) >= zoom_out_ytop && yworld_to_scrn(y) <= zoom_out_ybot) {
        zoom_out(drawscreen);
    }

    
      
    
    double load_xleft = obtainTranscoord().top_width - 92.5;
    double load_xright = obtainTranscoord().top_width - 52.5;
    double load_ytop = obtainTranscoord().top_height - 165;
    double load_ybot = obtainTranscoord().top_height - 195;
    // Load button was pressed
    if (xworld_to_scrn(x) >= load_xleft && xworld_to_scrn(x) <= load_xright && yworld_to_scrn(y) <= load_ytop && yworld_to_scrn(y) >= load_ybot) {
        StreetData::getObjectPtr()->loadPressed = true;
        panning_off();
        proceed(drawscreen);
    }

    
    
    
    // Info button
    double info_xleft = obtainTranscoord().top_width - 92.5;
    double info_xright = obtainTranscoord().top_width - 52.5;
    double info_ytop = obtainTranscoord().top_height - 210;
    double info_ybot = obtainTranscoord().top_height - 240;
    // Closest Intersection Enable
    if (xworld_to_scrn(x) >= info_xleft && xworld_to_scrn(x) <= info_xright && yworld_to_scrn(y) <= info_ytop && yworld_to_scrn(y) >= info_ybot) {
        findClosestIntersectionMode = true;
        draw_info_button(findClosestIntersectionMode);
    }

    
    
    double find_xleft = obtainTranscoord().top_width - 92.5;
    double find_xright = obtainTranscoord().top_width - 52.5;
    double find_ytop = obtainTranscoord().top_height - 255;
    double find_ybot = obtainTranscoord().top_height - 285;
    // Find Button was pressed
    if (xworld_to_scrn(x) >= find_xleft && xworld_to_scrn(x) <= find_xright && yworld_to_scrn(y) >= find_ybot && yworld_to_scrn(y) <= find_ytop) {
        find();
    }

    
    
    double quit_xleft = obtainTranscoord().top_width - 20;
    double quit_xright = obtainTranscoord().top_width;
    double quit_ytop = 0;
    double quit_ybot = 20;
    // Close button was pressed
    if (xworld_to_scrn(x) >= quit_xleft && xworld_to_scrn(x) <= quit_xright && yworld_to_scrn(y) <= quit_ybot && yworld_to_scrn(y) >= quit_ytop) {
        proceed(drawscreen);
    }



    //MILESTONE3
    double clear_xleft = obtainTranscoord().top_width - 92.5;
    double clear_xright = obtainTranscoord().top_width - 52.5;
    double clear_ytop = obtainTranscoord().top_height - 345;
    double clear_ybot = obtainTranscoord().top_height - 375;
    // clear Button was pressed
    if (xworld_to_scrn(x) >= clear_xleft && xworld_to_scrn(x) <= clear_xright && yworld_to_scrn(y) >= clear_ybot && yworld_to_scrn(y) <= clear_ytop) {
        clearscreen();
        input.clear();
        StreetData::clear = true;
        intersection = false;
        //path button no longer green
        pathGreen = false;
        //intersection clicking count reset
        twoIntersections = 0;
        num_inter = 0;
        std::string string;
        StreetData::getObjectPtr()->highlightedStreetIDs = StreetData::getObjectPtr()->streetIDsByName[string];
        //the intersections clicked on the map no longer display because of the clear
        intersection_one_highlight = false;
        intersection_two_highlight = false;
        drawPath = false;
        //THIS WOULD CLEAR THE DIRECTION DISPLAY
        clickedOnClear = true;
        drawscreen();
    }


    //Milestone 3    
    double guide_xleft = obtainTranscoord().top_width - 65;
    double guide_xright = obtainTranscoord().top_width - 25;
    double guide_ytop = obtainTranscoord().top_height - 30;
    double guide_ybot = obtainTranscoord().top_height - 60;
    // Help Button was pressed
    if (xworld_to_scrn(x) >= guide_xleft && xworld_to_scrn(x) <= guide_xright && yworld_to_scrn(y) >= guide_ybot && yworld_to_scrn(y) <= guide_ytop) {
        draw_guide_button();
        help_message = true;
        guide_textbox();
    }
    // if it is true that the message is already showing but the user hasn't clicked the button, get rid of the message
    //now set it to false because it is not displaying
    else{
        if (help_message == true)
            drawscreen();
        help_message = false;
    }




    //Milestone 3    Directions
    double directions_xleft = obtainTranscoord().top_width - 92.5;
    double directions_xright = obtainTranscoord().top_width - 52.5;
    double directions_ytop = obtainTranscoord().top_height - 300;
    double directions_ybot = obtainTranscoord().top_height - 330;
    // Directions Button was pressed
    if (xworld_to_scrn(x) >= directions_xleft && xworld_to_scrn(x) <= directions_xright && yworld_to_scrn(y) >= directions_ybot && yworld_to_scrn(y) <= directions_ytop) {
        clickedOnClear = false;
//the direction button has been clicked
        condition = true;
        pageNumber = 0;
        drawPath = true;
        drawscreen();
        directionErrorMsg = true; // you can display error
        directions = get_directions(savedPath);
        //takes the direction string vector and display it on the direction screen with the arrows and the page number
        give_directions(directions, pageNumber);

    } //THIS WAY IT WILL CONTINUE TO DRAW WHEN DRAGGING - ONLY WAY TO CLEAR IS WITH CLEAR BUTTON
    else {
        // cant display
        if (directionErrorMsg) {
            directionErrorMsg = false;
            drawscreen();
        }
    }



    //BUTTONS ARE INTERACTIVE FOR DIRECTIONS
    //left button for the direction menu
    double arrowL_xleft = obtainTranscoord().top_width / 20 - 10;
    double arrowL_xright = obtainTranscoord().top_width / 20 + 30;
    double arrowL_ytop = obtainTranscoord().top_height / 4 - 85;
    double arrowL_ybot = obtainTranscoord().top_height / 4 - 45;
    // Directions Button was pressed
    if (xworld_to_scrn(x) >= arrowL_xleft && xworld_to_scrn(x) <= arrowL_xright && yworld_to_scrn(y) >= arrowL_ytop && yworld_to_scrn(y) <= arrowL_ybot) {
        if (pageNumber > 0) {
            pageNumber--;
            give_directions(directions, pageNumber);
        }

    }

    
    
    //right button for the direction menu
    double arrowR_xleft = obtainTranscoord().top_width / 20 + 240;
    double arrowR_xright = obtainTranscoord().top_width / 20 + 280;
    double arrowR_ytop = obtainTranscoord().top_height / 4 - 85;
    double arrowR_ybot = obtainTranscoord().top_height / 4 - 45;
    // Directions Button was pressed
    if (xworld_to_scrn(x) >= arrowR_xleft && xworld_to_scrn(x) <= arrowR_xright && yworld_to_scrn(y) >= arrowR_ytop && yworld_to_scrn(y) <= arrowR_ybot) {
        if (pageNumber + 1 < (unsigned) ceil((double) directions.size() / (double) 6)) {
            pageNumber++;
            give_directions(directions, pageNumber);
        }
    }




    //TO BE USED FOR M3 PATH ALGORITHM
    // for displaying optimal path and taking in input
    double path_xleft = obtainTranscoord().top_width / 2 + 190;
    double path_xright = obtainTranscoord().top_width / 2 + 235;
    double path_ytop = obtainTranscoord().top_height / 10 - 20;
    double path_ybot = obtainTranscoord().top_height / 10 + 20;
    // Path Button was pressed    
    if (xworld_to_scrn(x) >= path_xleft && xworld_to_scrn(x) <= path_xright && yworld_to_scrn(y) >= path_ytop && yworld_to_scrn(y) <= path_ybot) {
        pathGreen = true;
        draw_path_button(pathGreen);
        searchbar_clicked = true;
        search_box.draw(searchbar_clicked);
        num_inter = 0;
    }

}





//MILESTONE3
void draw_clear_button() {
    settextrotation(0);
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(10);

    setcolor(WHITE);


    // Info button
    double clear_xleft = obtainTranscoord().top_width - 92.5;
    double clear_xright = obtainTranscoord().top_width - 52.5;
    double clear_ytop = obtainTranscoord().top_height - 345;
    double clear_ybot = obtainTranscoord().top_height - 375;

    fillrect(xscrn_to_world(clear_xleft), yscrn_to_world(clear_ytop), xscrn_to_world(clear_xright), yscrn_to_world(clear_ybot));
    setcolor(BLACK);
    drawtext(xscrn_to_world(clear_xleft + 20), yscrn_to_world(clear_ytop - 15), "Clear", 1, 1);

}





// MILESTONE 3
void draw_guide_button() {
    settextrotation(0);
    setfontsize(20);
    setlinestyle(SOLID);
    setlinewidth(10);

    setcolor(WHITE);

    // Info button
    double guide_xleft = obtainTranscoord().top_width - 65;
    double guide_xright = obtainTranscoord().top_width - 25;
    double guide_ytop = obtainTranscoord().top_height - 30;
    double guide_ybot = obtainTranscoord().top_height - 60;

    fillrect(xscrn_to_world(guide_xleft), yscrn_to_world(guide_ytop), xscrn_to_world(guide_xright), yscrn_to_world(guide_ybot));
    setcolor(BLACK);
    drawtext(xscrn_to_world(guide_xleft + 20), yscrn_to_world(guide_ytop - 15), "?", 1, 1);

}





// MILESTONE 3

void draw_direction_button() {
    settextrotation(0);
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(10);


    setcolor(WHITE);


    // Info button
    double guide_xleft = obtainTranscoord().top_width - 92.5;
    double guide_xright = obtainTranscoord().top_width - 52.5;
    double guide_ytop = obtainTranscoord().top_height - 300;
    double guide_ybot = obtainTranscoord().top_height - 330;

    fillrect(xscrn_to_world(guide_xleft), yscrn_to_world(guide_ytop), xscrn_to_world(guide_xright), yscrn_to_world(guide_ybot));
    setcolor(BLACK);
    drawtext(xscrn_to_world(guide_xleft + 20), yscrn_to_world(guide_ytop - 15), "Dir.", 1, 1);
}








//MILESTONE3
void draw_path_button(bool pathGreen) {
    settextrotation(0);
    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(3);

//button turns green when in use
    if (pathGreen == true) 
        setcolor(GREEN);
    else 
        setcolor(WHITE);
    

    // Info button
    double path_xleft = obtainTranscoord().top_width / 2 + 190;
    double path_xright = obtainTranscoord().top_width / 2 + 235;
    double path_ytop = obtainTranscoord().top_height / 10 - 20;
    double path_ybot = obtainTranscoord().top_height / 10 + 20;

    fillrect(xscrn_to_world(path_xleft), yscrn_to_world(path_ytop), xscrn_to_world(path_xright), yscrn_to_world(path_ybot));
    setcolor(BLACK);
    drawtext(xscrn_to_world(path_xleft + 22), yscrn_to_world(path_ytop + 18), "Path", 1, 1);
}






void drawscreen(void) {
    StreetData::getObjectPtr()->zoomLevel = (xscrn_to_world(100) - xscrn_to_world(0))*10000;

    set_draw_mode(DRAW_NORMAL);
    clearscreen(); // Needed before we can redraw

    // Draw order is important, functions called at the bottom will be drawn at the very top
    draw_features();
    draw_streets();
    if (drawPath) {
        draw_path(savedPath);
    }
    draw_street_names();
    draw_points_of_interest();
    draw_info_highlight();
    if (intersection == true)
        draw_found_intersections();

    draw_buttons();
    draw_info_button(findClosestIntersectionMode);
    //MILESTONE 3 is the command below for the intersection highlight for path
    if (intersection_one_highlight == true)
        draw_intersection_one_highlight();
    if (intersection_two_highlight == true)
        draw_intersection_two_highlight();

    draw_quit();
    draw_searchbox(searchbox_mode);
    draw_scale();
    draw_guide_button();
    draw_direction_button();
    draw_clear_button();
    draw_path_button(pathGreen);
    if (clickedOnClear == false) {
        directions = get_directions(savedPath);
        give_directions(directions, pageNumber);
    }
}






void intersection_highlight(float x, float y) {

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2;
    double scalingFactor = cos(lat_avg * DEG_TO_RAD);

    // Find the closest intersection given our x and y
    LatLon searchPos;
    searchPos.lat = y;
    searchPos.lon = x / scalingFactor;
    unsigned closestIntersection = find_closest_intersection(searchPos);

    // Check to see if the distance between the click location and the nearest intersection is within an acceptable range
    if (find_distance_between_two_points(searchPos, getIntersectionPosition(closestIntersection)) < StreetData::getObjectPtr()->zoomLevel) {

        // Draw the highlighting of the closest intersection
        draw_info_highlight(closestIntersection);

        // Print message with info about that intersection
        std::string message = "Intersection ID: " + std::to_string(closestIntersection) + "\nIntersecting Streets:";
        std::vector<std::string> uniqueNames = StreetData::getObjectPtr()->streetNamesBlonIntersection[closestIntersection];
        std::sort(uniqueNames.begin(), uniqueNames.end());
        std::vector<std::string>::iterator it = std::unique(uniqueNames.begin(), uniqueNames.end());

        uniqueNames.resize(std::distance(uniqueNames.begin(), it));

        for (unsigned i = 0; i < uniqueNames.size(); i++) {\
            if (uniqueNames[i] == "<unknown>") {
                message = message + "\n   " + "Unknown";
            } else {
                message = message + "\n   " + uniqueNames[i];
            }
        }
        message = message + "\nStreet segment IDs:";
        std::vector<unsigned> streetSegs = StreetData::getObjectPtr()->streetSegsByIntersectionID[closestIntersection];
        for (unsigned i = 0; i < streetSegs.size(); i++) {
            message = message + "\n   " + std::to_string(streetSegs[i]);
        }

        unsigned nearestPOIID = find_closest_point_of_interest(getIntersectionPosition(closestIntersection));
        message = message + "\nNearest Point of Interest:\n   " + getPointOfInterestName(nearestPOIID);
        std::cout << message << std::endl;
        std::thread thread(tinyfd_messageBox, "Info", message.c_str(), "ok", "info", 1); // You have to make the message box run in a seperate thread or else it freezes the map in the background
        thread.detach();
    }
    drawscreen();
}





//works with the path button
//MILESTONE 3 HIGHLIGHT INTERSECTION ON CLICK
void click_two_intersections(float x, float y) {

    double lat_avg = (StreetData::getObjectPtr()->latIntersectionMin + StreetData::getObjectPtr()->latIntersectionMax) / 2;
    double scalingFactor = cos(lat_avg * DEG_TO_RAD);

    // Find the closest intersection given our x and y
    LatLon searchPos;
    searchPos.lat = y;
    searchPos.lon = x / scalingFactor;
    unsigned closestIntersection = find_closest_intersection(searchPos);

    // Check to see if the distance between the click location and the nearest intersection is within an acceptable range
    if (find_distance_between_two_points(searchPos, getIntersectionPosition(closestIntersection)) < StreetData::getObjectPtr()->zoomLevel) {

        // Draw the highlighting of the closest intersection

        if (twoIntersections == 0) {
            draw_intersection_one_highlight(closestIntersection);
            intersection_one_highlight = true;
            intersection_two_highlight = false;
            properFirstIntersection = true;
            std::cout << closestIntersection << std::endl;
            //store the id on the first valid click
            intersectionIdOne = closestIntersection;
        }

        if (twoIntersections == 1) {
            draw_intersection_two_highlight(closestIntersection);
            intersection_two_highlight = true;
            properSecondIntersection = true;
            std::cout << closestIntersection << std::endl;
            //store the id on the first valid click
            intersectionIdTwo = closestIntersection;
        }
    }        //make sure to otherwise set the proper input to false
    else if (twoIntersections == 0) {
        properFirstIntersection = false;
        intersection_one_highlight = false;
        intersection_two_highlight = false;
    } else if (twoIntersections == 1) {
        properSecondIntersection = false;
    }


    //checks for any bad inputs to the path algorithm and stops it from proceeding
    if (twoIntersections == 0) {
        if ((properFirstIntersection == false)) {

            settextrotation(0);
            setfontsize(14);
            setlinestyle(SOLID);
            setlinewidth(3);
            setcolor(WHITE);

            //location of suggestion info area
            double sinfo_xleft =  obtainTranscoord().top_width/2-170;
            double sinfo_ytop = obtainTranscoord().top_height/10+25;
            double sinfo_xright = obtainTranscoord().top_width/2+170;
            double sinfo_ybot = obtainTranscoord().top_height/10+70;
            fillrect(xscrn_to_world(sinfo_xleft), yscrn_to_world(sinfo_ytop), xscrn_to_world(sinfo_xright), yscrn_to_world(sinfo_ybot));
            setcolor(BLACK);

            drawtext(xscrn_to_world(obtainTranscoord().top_width/2), yscrn_to_world(sinfo_ytop + 25), "Improper Path Input", 1, 1);
            intersectionIdOne = 0;
        }
    }
    
    
 
    // for the second click check if valid
    if (twoIntersections == 1) {

        if ((properSecondIntersection == false)) {
            std::cout << "Improper Path Input!" << std::endl;

            settextrotation(0);
            setfontsize(14);
            setlinestyle(SOLID);
            setlinewidth(3);
            setcolor(WHITE);

            //size of error message
            double sinfo_xleft = obtainTranscoord().top_width / 2 - 170;
            double sinfo_ytop = obtainTranscoord().top_height / 10 + 25;
            double sinfo_xright = obtainTranscoord().top_width / 2 + 170;
            double sinfo_ybot = obtainTranscoord().top_height / 10 + 70;
            fillrect(xscrn_to_world(sinfo_xleft), yscrn_to_world(sinfo_ytop), xscrn_to_world(sinfo_xright), yscrn_to_world(sinfo_ybot));
            setcolor(BLACK);

            drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(sinfo_ytop + 25), "Improper Path Input", 1, 1);


            intersectionIdTwo = 0;
            properFirstIntersection = false;
        }
    }
    if (twoIntersections == 0) {
        drawPath = false;
        condition = false;
    }
    if (properSecondIntersection && properFirstIntersection && twoIntersections == 1) {
        intersection1 = intersectionIdOne;
        intersection2 = intersectionIdTwo;
        drawPath = true;
        condition = true;
        pageNumber = 0;
        savedPath = find_path_between_intersections(intersection1,intersection2);
        directions = get_directions(savedPath);
    } else if (twoIntersections == 1) {
        intersection_one_highlight = false;
        intersection_two_highlight = false;
    }


    drawscreen();
    if ((twoIntersections == 0 && properFirstIntersection == false) || (twoIntersections == 1 && properSecondIntersection == false)) {
        settextrotation(0);
        setfontsize(14);
        setlinestyle(SOLID);
        setlinewidth(3);
        setcolor(WHITE);

        //size of error message
        double sinfo_xleft = obtainTranscoord().top_width / 2 - 170;
        double sinfo_ytop = obtainTranscoord().top_height / 10 + 25;
        double sinfo_xright = obtainTranscoord().top_width / 2 + 170;
        double sinfo_ybot = obtainTranscoord().top_height / 10 + 70;
        fillrect(xscrn_to_world(sinfo_xleft), yscrn_to_world(sinfo_ytop), xscrn_to_world(sinfo_xright), yscrn_to_world(sinfo_ybot));
        setcolor(BLACK);

        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(sinfo_ytop + 25), "Improper Path Input", 1, 1);
        twoIntersections = 2;
    }
}








// MILESTONE 3
//this is the output of the helper button
void guide_textbox() {

    if (help_message == true) {
        settextrotation(0);

        setlinestyle(SOLID);

        setcolor(WHITE);

        //size of the help menu (size of the white box where the text is drawn)
        double sinfo_xleft = obtainTranscoord().top_width / 2 - 500;
        double sinfo_xright = obtainTranscoord().top_width / 2 + 500;
        double sinfo_ytop = obtainTranscoord().top_height / 10 + 100;
        double sinfo_ybot = obtainTranscoord().top_height / 10 + 470;
        fillrect(xscrn_to_world(sinfo_xleft), yscrn_to_world(sinfo_ytop), xscrn_to_world(sinfo_xright), yscrn_to_world(sinfo_ybot));
        setcolor(BLACK);

        //output messages for the help button
        //title
        setfontsize(20);
        setlinewidth(8);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2), yscrn_to_world(sinfo_ytop + 20), "How to Use Interface", 1, 1);

        setfontsize(12);
        setlinewidth(3);

        //instructions and information
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 235), yscrn_to_world(sinfo_ytop + 55), "- Load button: allows you to load any map.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 98), yscrn_to_world(sinfo_ytop + 85), "- Info button: click on any intersection on the map and receive information about it.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 40), yscrn_to_world(sinfo_ytop + 115), "- Find button: type in 2 street names and find their intersection shown as a pink circle if one exists.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 5), yscrn_to_world(sinfo_ytop + 145), "- Clear button: clear any highlighted streets or intersections on the map and reset it to its default appearance.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 45), yscrn_to_world(sinfo_ytop + 175), "- Path button: cntrl click on two intersections on the map and find the optimal path between them.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 148), yscrn_to_world(sinfo_ytop + 205), "- Dir. button: will show the directions of the path shown on the map.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 216), yscrn_to_world(sinfo_ytop + 235), "- Search bar: takes three different types of input: ", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 135), yscrn_to_world(sinfo_ytop + 265), " * If one street is typed in, the street will be highlighted.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 100), yscrn_to_world(sinfo_ytop + 295), " * If two streets are typed in, their intersection will be highlighted.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 + 50), yscrn_to_world(sinfo_ytop + 325), " * Click on path button, if one street and one point of interest are typed, an optimal path draws between them.", 1, 1);
        drawtext(xscrn_to_world(obtainTranscoord().top_width / 2 - 11), yscrn_to_world(sinfo_ytop + 355), " * Click on path button, if two intersections are typed, an optimal path draws between them.", 1, 1);

    }
}






void find() {
    // Get street #1
    std::string street1 = "";
    char* result = (char*) tinyfd_inputBox("Enter Street Name", "Please enter street name #1", "");
    if (result != NULL) {
        street1 = result;
    }
    // Get street #2
    std::string street2 = "";
    result = (char*) tinyfd_inputBox("Enter Street Name", "Please enter street name #2", "");
    if (result != NULL) {
        street2 = result;
    }
    // Find the common intersections
    std::vector<unsigned> intersections = find_intersection_ids_from_street_names(street1, street2);
    // Print out the common intersection IDs and highlight them on the map
    std::cout << "Intersection IDs: ";
    for (unsigned i = 0; i < intersections.size(); i++) {
        std::cout << intersections[i];
        if (i != intersections.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << std::endl;
    intersection = true;
    draw_found_intersections(intersections);
}
